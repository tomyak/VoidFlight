<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Void Flight</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; color: white; user-select: none; touch-action: none; }
        #canvas-container { width: 100%; height: 100vh; display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.7); z-index: 20; transition: opacity 0.5s; }
        #hud { position: absolute; top: 20px; left: 20px; pointer-events: none; display: none; text-shadow: 0 0 5px cyan; }
        h1 { font-size: 2rem; text-transform: uppercase; letter-spacing: 5px; margin-bottom: 10px; text-shadow: 0 0 10px white; }
        p { color: #aaa; margin-bottom: 30px; text-align: center; max-width: 80%; }
        button { background: transparent; color: white; border: 2px solid white; padding: 15px 40px; font-size: 1.2rem; font-family: inherit; cursor: pointer; text-transform: uppercase; transition: all 0.3s; }
        button:hover { background: white; color: black; box-shadow: 0 0 20px rgba(255,255,255,0.5); }
        .hidden { opacity: 0; pointer-events: none; }
        
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 1px solid rgba(255,255,255,0.3); transform: translate(-50%, -50%); pointer-events: none; display: none; }
        #crosshair::after { content: ''; position: absolute; top: 50%; left: 50%; width: 2px; height: 2px; background: white; transform: translate(-50%, -50%); }

        #vector-indicator { position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; border: 2px solid cyan; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; box-shadow: 0 0 10px cyan; transition: top 0.1s, left 0.1s; }

        /* Compass & Horizon */
        #compass-container { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 80px; height: 80px; border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.3); background: rgba(0, 0, 0, 0.2); display: none; pointer-events: none; }
        
        /* Mask for inner compass elements so horizon line doesn't bleed out */
        #compass-mask { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%; overflow: hidden; }
        
        #compass-dial { width: 100%; height: 100%; position: relative; border-radius: 50%; transition: transform 0.1s linear; }
        #horizon-bar { position: absolute; top: 50%; left: 50%; width: 200%; height: 2px; background: rgba(0, 255, 255, 0.6); transform: translate(-50%, -50%); transform-origin: center; z-index: 1; transition: transform 0.1s linear; }
        
        /* Day Cycle Indicators (Outside the mask) */
        #day-track { position: absolute; top: -8px; left: -8px; right: -8px; bottom: -8px; border: 1px solid rgba(255,255,255,0.1); border-radius: 50%; pointer-events: none; }
        #day-marker-pivot { position: absolute; top: 50%; left: 50%; width: 100%; height: 100%; transform: translate(-50%, -50%); }
        #day-icon { position: absolute; top: -22px; left: 50%; transform: translateX(-50%); font-size: 14px; text-shadow: 0 0 5px currentColor; transition: color 0.5s; }

        .dir { position: absolute; font-weight: bold; font-size: 12px; color: rgba(255, 255, 255, 0.8); text-shadow: 0 0 2px black; }
        .dir.n { top: 5px; left: 50%; transform: translateX(-50%); color: #ff4444; }
        .dir.s { bottom: 5px; left: 50%; transform: translateX(-50%); }
        .dir.e { right: 5px; top: 50%; transform: translateY(-50%); }
        .dir.w { left: 5px; top: 50%; transform: translateY(-50%); }
        #compass-marker { position: absolute; top: -5px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 5px solid transparent; border-right: 5px solid transparent; border-top: 8px solid white; z-index: 5; }
        #heading-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 10px; color: rgba(68, 170, 136, 0.8); z-index: 6; text-shadow: 0 0 2px black; }

        /* MINIMAP */
        #minimap-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            overflow: hidden;
            display: none;
            pointer-events: none;
            opacity: 0.25;
        }
        #minimap-canvas { width: 100%; height: 100%; display: block; }

        #joystick-zone { position: absolute; bottom: 30px; right: 30px; width: 120px; height: 120px; border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 50%; background: rgba(0, 0, 0, 0.3); backdrop-filter: blur(2px); display: none; z-index: 15; }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; margin-top: -25px; margin-left: -25px; border-radius: 50%; background: rgba(255, 255, 255, 0.8); box-shadow: 0 0 15px rgba(255, 255, 255, 0.5); transition: transform 0.05s; }

        /* Throttle Thinner */
        #throttle-zone { position: absolute; bottom: 30px; left: 30px; width: 30px; height: 200px; border: 2px solid rgba(255, 255, 255, 0.2); background: rgba(0, 0, 0, 0.3); backdrop-filter: blur(2px); display: none; z-index: 15; }
        #throttle-fill { position: absolute; bottom: 0; left: 0; width: 100%; height: 15%; background: rgba(68, 170, 136, 0.5); transition: height 0.1s linear; }
        #throttle-level { position: absolute; bottom: 15%; left: -5px; right: -5px; height: 10px; background: white; border-radius: 5px; box-shadow: 0 0 10px white; }
        #throttle-zero-line { position: absolute; bottom: 15%; left: 0; width: 100%; height: 2px; background: rgba(255,255,255,0.5); pointer-events: none; }

        /* Light Zone Thinner + Button */
        #light-zone { position: absolute; bottom: 250px; left: 30px; width: 30px; height: 100px; border: 2px solid rgba(255, 255, 255, 0.2); background: rgba(0, 0, 0, 0.3); backdrop-filter: blur(2px); display: none; z-index: 15; }
        #light-fill { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: rgba(255, 255, 200, 0.5); transition: height 0.1s linear; }
        #light-level { position: absolute; bottom: 0%; left: -5px; right: -5px; height: 10px; background: white; border-radius: 5px; box-shadow: 0 0 10px white; }
        
        #light-mode-btn { position: absolute; top: -60px; left: 50%; transform: translateX(-50%); width: 50px; height: 50px; border: 1px solid rgba(255,255,255,0.5); color: white; border-radius: 50%; text-align: center; line-height: 48px; cursor: pointer; font-size: 24px; pointer-events: auto; background: rgba(0,0,0,0.5); }
        
        .label { position: absolute; font-size: 10px; color: #aaa; width: 100%; text-align: center; }
        .icon { font-size: 14px; position: absolute; width: 100%; text-align: center; top: 50%; transform: translateY(-50%); pointer-events: none; opacity: 0.5; }

        #key-hint { position: absolute; top: 100px; right: 20px; text-align: right; color: rgba(255,255,255,0.5); font-size: 12px; pointer-events: none; display: none; }

        /* Hidden Elements */
        #crosshair { display: none !important; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>Void Flight</h1>
        <p>1. Hold phone comfortably (Upright)<br>2. Press Start</p>
        <button id="start-btn">Start</button>
    </div>

    <div id="hud">ALT: <span id="alt-disp">0000</span><br>SPD: <span id="spd-disp">MACH 0.0</span></div>
    
    <div id="key-hint">
        ARROWS: Manual Override<br>
        W/S: Throttle<br>
        0-9: Lights<br>
        MOUSE/PHONE: Look
    </div>

    <div id="compass-container">
        <div id="day-track"></div>
        <div id="day-marker-pivot"><div id="day-icon">☾</div></div>
        
        <div id="compass-mask">
            <div id="horizon-bar"></div>
            <div id="heading-text">000</div>
            <div id="compass-dial"><span class="dir n">N</span><span class="dir e">E</span><span class="dir s">S</span><span class="dir w">W</span></div>
        </div>
        <div id="compass-marker"></div>
    </div>

    <div id="minimap-container">
        <canvas id="minimap-canvas" width="150" height="150"></canvas>
    </div>

    <div id="joystick-zone"><div id="joystick-knob"></div></div>
    
    <div id="throttle-zone">
        <div class="label" style="top: -20px">SPD</div>
        <div id="throttle-fill"></div><div id="throttle-level"></div>
        <div class="label" style="bottom: -20px">MIN</div>
    </div>

    <div id="light-zone">
        <div id="light-mode-btn" title="Toggle Search/Focus">⌖</div>
        <div class="label" style="top: -20px">LGT</div>
        <div id="light-fill"></div><div id="light-level"></div>
        <div class="icon">☀</div>
        <div class="label" style="bottom: -20px">OFF</div>
    </div>

    <div id="crosshair"></div>
    <div id="vector-indicator"></div> 
    
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- 1. TEXTURES ---
        function generateTerrainTexture() {
            const size = 512; const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size; const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#111'; ctx.fillRect(0, 0, size, size);
            for (let i = 0; i < 4000; i++) {
                const x = Math.random() * size; const y = Math.random() * size; const w = Math.random() * 50 + 10; const h = Math.random() * 50 + 10;
                const shade = Math.floor(Math.random() * 50); ctx.fillStyle = `rgba(0, ${shade + 50}, ${shade + 60}, 0.1)`; ctx.fillRect(x, y, w, h);
            }
            ctx.strokeStyle = 'rgba(68, 170, 136, 0.2)'; ctx.lineWidth = 2; ctx.beginPath();
            const step = 64; for(let i=0; i<=size; i+=step) { ctx.moveTo(i, 0); ctx.lineTo(i, size); ctx.moveTo(0, i); ctx.lineTo(size, i); } ctx.stroke();
            const texture = new THREE.CanvasTexture(canvas); texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; texture.repeat.set(4, 4);
            return texture;
        }
        function generateBuildingTexture() {
            const size = 256; const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size; const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#050505'; ctx.fillRect(0,0,size,size); ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
            for(let i=0; i<40; i++) { if(Math.random() > 0.5) { const x = Math.floor(Math.random() * 8) * 32; const y = Math.floor(Math.random() * 8) * 32; ctx.fillRect(x+4, y+4, 20, 20); } }
            const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter; return tex;
        }
        const terrainTexture = generateTerrainTexture();
        const buildingTexture = generateBuildingTexture();

        // --- NOISE ---
        class SimpleNoise {
            constructor(seed = Math.random()) { this.seed = seed; this.perm = new Uint8Array(512); this.p = new Uint8Array(256); for (let i = 0; i < 256; i++) this.p[i] = i; for (let i = 0; i < 256; i++) { let r = Math.floor(Math.abs(Math.sin(this.seed * (i + 1)) * 256)); let temp = this.p[i]; this.p[i] = this.p[r]; this.p[r] = temp; this.perm[i] = this.perm[i + 256] = this.p[i]; } }
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); } lerp(t, a, b) { return a + t * (b - a); } grad(hash, x, y, z) { let h = hash & 15; let u = h < 8 ? x : y; let v = h < 4 ? y : h === 12 || h === 14 ? x : z; return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v); }
            noise2D(x, y) { x = x * 0.003; y = y * 0.003; let X = Math.floor(x) & 255; let Y = Math.floor(y) & 255; x -= Math.floor(x); y -= Math.floor(y); let u = this.fade(x); let v = this.fade(y); let A = this.perm[X] + Y, B = this.perm[X + 1] + Y; return (this.lerp(v, this.lerp(u, this.grad(this.perm[A], x, y, 0), this.grad(this.perm[B], x - 1, y, 0)), this.lerp(u, this.grad(this.perm[A + 1], x, y - 1, 0), this.grad(this.perm[B + 1], x - 1, y - 1, 0)))) * 100; }
        }

        // --- MONSTER CLASS ---
        class Monster {
            constructor(group, x, z, y) {
                this.mesh = new THREE.Group();
                this.mesh.position.set(x, y, z);
                
                const bodyMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
                const eyeMat = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x888888, specular: 0xffffff, shininess: 100 });

                this.torsoGroup = new THREE.Group();
                this.torsoGroup.position.y = 12; 
                this.mesh.add(this.torsoGroup);

                const torso = new THREE.Mesh(new THREE.BoxGeometry(5, 14, 3), bodyMat); torso.position.y = 7; this.torsoGroup.add(torso);
                this.head = new THREE.Mesh(new THREE.BoxGeometry(6, 7, 6), bodyMat); this.head.position.y = 17; this.torsoGroup.add(this.head);
                
                const eyeGeo = new THREE.SphereGeometry(1.2, 8, 8);
                this.lEye = new THREE.Mesh(eyeGeo, eyeMat); this.lEye.position.set(-1.5, 0, 3); this.head.add(this.lEye);
                this.rEye = new THREE.Mesh(eyeGeo, eyeMat); this.rEye.position.set(1.5, 0, 3); this.head.add(this.rEye);

                const createLimb = (w, h, d, px, py) => {
                    const grp = new THREE.Group(); grp.position.set(px, py, 0);
                    grp.add(new THREE.Mesh(new THREE.BoxGeometry(w, h, d), bodyMat)).position.y = -h/2; 
                    return grp;
                };

                this.lArm = createLimb(2.5, 16, 2.5, -4.5, 13); this.torsoGroup.add(this.lArm);
                this.rArm = createLimb(2.5, 16, 2.5, 4.5, 13); this.torsoGroup.add(this.rArm);
                this.lLeg = createLimb(3, 14, 3, -2, 12); this.mesh.add(this.lLeg);
                this.rLeg = createLimb(3, 14, 3, 2, 12); this.mesh.add(this.rLeg);

                group.add(this.mesh);

                this.dest = new THREE.Vector3(x, y, z);
                this.waitTimer = 0;
                this.walkTime = Math.random() * 100;
                this.speed = 0.2;
            }

            update(dt, terrainFn, chunkX, chunkZ) {
                let isMoving = false;
                if (this.waitTimer > 0) {
                    this.waitTimer -= dt;
                    this.torsoGroup.scale.y = 1 + Math.sin(performance.now() * 0.005) * 0.02;
                } else {
                    const d = this.dest.clone().sub(this.mesh.position);
                    d.y = 0; 
                    if (d.length() < 5) {
                        this.dest.x = this.mesh.position.x + (Math.random() - 0.5) * 100;
                        this.dest.z = this.mesh.position.z + (Math.random() - 0.5) * 100;
                        this.waitTimer = Math.random() * 2000 + 500;
                        this.lArm.rotation.x = 0; this.rArm.rotation.x = 0; this.lLeg.rotation.x = 0; this.rLeg.rotation.x = 0;
                    } else {
                        isMoving = true;
                        d.normalize().multiplyScalar(this.speed); 
                        this.mesh.position.x += d.x; this.mesh.position.z += d.z;
                        this.mesh.lookAt(this.dest.x + chunkX, this.mesh.position.y, this.dest.z + chunkZ);
                        this.mesh.position.y = terrainFn(chunkX + this.mesh.position.x, chunkZ + this.mesh.position.z);
                        this.walkTime += dt * 0.01;
                    }
                }
                if(isMoving) {
                    const t = this.walkTime * 0.8; 
                    this.lLeg.rotation.x = Math.sin(t) * 0.8; this.rLeg.rotation.x = Math.sin(t + Math.PI) * 0.8;
                    this.lArm.rotation.x = Math.sin(t + Math.PI) * 0.6; this.rArm.rotation.x = Math.sin(t) * 0.6;
                    this.lArm.rotation.z = 0.2; this.rArm.rotation.z = -0.2;
                    this.torsoGroup.position.y = 12 + Math.abs(Math.sin(t)) * 1.5; this.torsoGroup.rotation.x = 0.2;
                } else {
                    this.lLeg.rotation.x *= 0.9; this.rLeg.rotation.x *= 0.9;
                    this.lArm.rotation.x *= 0.9; this.rArm.rotation.x *= 0.9;
                    this.torsoGroup.rotation.x *= 0.9; this.torsoGroup.position.y = 12 + Math.sin(performance.now() * 0.002) * 0.5;
                }
            }
        }

        // --- CONFIG ---
        const CONFIG = {
            chunkSize: 200,
            renderDistance: 6,
            minSpeed: 0.5,  // Positive min speed
            maxSpeed: 2.0,
            speed: 0.5,     // Start at minSpeed
            bgColor: 0x050505,
            wireColor: 0x44aa88,
            dayDuration: 5 * 60 * 1000,
            minLight: 1.5,
            maxLight: 5.5
        };

        // --- GLOBALS ---
        let scene, camera, renderer;
        let ship, worldGroup; 
        let terrainChunks = {};
        const noise = new SimpleNoise(12345);
        let isFlying = false;

        // HUD Globals
        let compassDial, headingText, altDisp, spdDisp, horizonBar, dayPivot, dayIcon;

        // Map Globals
        let minimapCtx, mapCanvas, mapContainer;

        // Inputs
        const joyInput = { x: 0, y: 0 }; 
        const lookInput = { x: 0, y: 0 };
        const keys = {}; 
        
        const shipState = { pitch: 0, yaw: 0 };
        const camState = { pitch: 0, yaw: 0 };

        // Orientation
        let deviceRefQuat = new THREE.Quaternion();
        let currentDeviceQuat = new THREE.Quaternion();
        let useDeviceOrientation = false;

        // Lights & Raycast
        let spotTL, spotTR, spotBL, spotBR;
        let targetTL, targetTR, targetBL, targetBR;
        const raycaster = new THREE.Raycaster();
        let isUsingJoystick = false;
        
        // Light Mode
        let lightMode = 'focus'; 

        // Audio
        let audioCtx, engineOsc, engineGain;

        // Particles
        const particles = [];
        const smokeGeo = new THREE.IcosahedronGeometry(6, 0); 
        const smokeMat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.4 });

        // Environmental
        let ambientLight, sunLight;

        // --- INIT ---
        function init() {
            // HUD Elements
            compassDial = document.getElementById('compass-dial');
            headingText = document.getElementById('heading-text');
            altDisp = document.getElementById('alt-disp');
            spdDisp = document.getElementById('spd-disp');
            horizonBar = document.getElementById('horizon-bar');
            dayPivot = document.getElementById('day-marker-pivot');
            dayIcon = document.getElementById('day-icon');
            
            // Map
            mapContainer = document.getElementById('minimap-container');
            mapCanvas = document.getElementById('minimap-canvas');
            minimapCtx = mapCanvas.getContext('2d');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.bgColor);
            scene.fog = new THREE.FogExp2(CONFIG.bgColor, 0.0015);

            // World Group for Terrain (Raycasting target)
            worldGroup = new THREE.Group();
            scene.add(worldGroup);

            // SHIP
            ship = new THREE.Object3D();
            ship.position.set(0, 300, 0);
            scene.add(ship);

            // CAMERA (Parented to Ship)
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
            ship.add(camera); // CONNECTED TO SHIP

            // HEADLIGHT TARGETS (Independent World Space)
            targetTL = new THREE.Object3D(); scene.add(targetTL);
            targetTR = new THREE.Object3D(); scene.add(targetTR);
            targetBL = new THREE.Object3D(); scene.add(targetBL);
            targetBR = new THREE.Object3D(); scene.add(targetBR);

            // Lights on Camera
            const beamAngle = Math.PI / 15;
            const beamDist = 1500;
            const beamPen = 0.5;

            // Top Left
            spotTL = new THREE.SpotLight(0xffffee, 0); spotTL.position.set(-15, 10, -5); 
            spotTL.angle = beamAngle; spotTL.penumbra = beamPen; spotTL.distance = beamDist; spotTL.target = targetTL; spotTL.castShadow = true;
            camera.add(spotTL); 

            // Top Right
            spotTR = new THREE.SpotLight(0xffffee, 0); spotTR.position.set(15, 10, -5); 
            spotTR.angle = beamAngle; spotTR.penumbra = beamPen; spotTR.distance = beamDist; spotTR.target = targetTR; spotTR.castShadow = true;
            camera.add(spotTR); 

            // Bottom Left
            spotBL = new THREE.SpotLight(0xffffee, 0); spotBL.position.set(-15, -10, -5); 
            spotBL.angle = beamAngle; spotBL.penumbra = beamPen; spotBL.distance = beamDist; spotBL.target = targetBL; spotBL.castShadow = true;
            camera.add(spotBL); 

            // Bottom Right
            spotBR = new THREE.SpotLight(0xffffee, 0); spotBR.position.set(15, -10, -5); 
            spotBR.angle = beamAngle; spotBR.penumbra = beamPen; spotBR.distance = beamDist; spotBR.target = targetBR; spotBR.castShadow = true;
            camera.add(spotBR); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // BRIGHT AMBIENT LIGHT
            ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 0.5); 
            sunLight.position.set(100, 300, -100);
            scene.add(sunLight);

            window.addEventListener('resize', onWindowResize, false);
            setupControls();
            animate();
        }

        // --- MATH: DEVICE ORIENTATION ---
        function setQuaternion(quaternion, alpha, beta, gamma, orient) {
            const euler = new THREE.Euler();
            const q0 = new THREE.Quaternion();
            const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); 

            const _x = beta ? beta * Math.PI / 180 : 0;
            const _y = gamma ? gamma * Math.PI / 180 : 0;
            const _z = alpha ? alpha * Math.PI / 180 : 0;

            euler.set(_x, _z, -_y, 'YXZ');
            quaternion.setFromEuler(euler);
            quaternion.multiply(q1); 
            const minusHalfAngle = -orient * Math.PI / 360;
            q0.set(0, 0, Math.sin(minusHalfAngle), Math.cos(minusHalfAngle));
            quaternion.multiply(q0);
        }

        // --- AUDIO ---
        function initAudio() {
            // const AudioContext = window.AudioContext || window.webkitAudioContext;
            // audioCtx = new AudioContext();
            // engineOsc = audioCtx.createOscillator(); engineOsc.type = 'sawtooth'; engineOsc.frequency.value = 50; 
            // engineGain = audioCtx.createGain(); engineGain.gain.value = 0.05; 
            // engineOsc.connect(engineGain); engineGain.connect(audioCtx.destination); engineOsc.start();
        }
        function updateAudio() {
            if(!audioCtx) return;
            const speedRatio = Math.abs(CONFIG.speed) / CONFIG.maxSpeed;
            engineOsc.frequency.setTargetAtTime(50 + (speedRatio * 100), audioCtx.currentTime, 0.1);
            engineGain.gain.setTargetAtTime(0.05 + (speedRatio * 0.1), audioCtx.currentTime, 0.1);
        }

        // --- PARTICLES ---
        function spawnSmoke() {
            if(Math.abs(CONFIG.speed) < 0.05) return;
            const mesh = new THREE.Mesh(smokeGeo, smokeMat.clone()); 
            const offset = new THREE.Vector3(0, 0, 15); offset.applyMatrix4(ship.matrixWorld);
            mesh.position.copy(offset); mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            scene.add(mesh); particles.push({ mesh: mesh, life: 1.0 });
        }
        function updateParticles() {
            const spawnChance = Math.abs(CONFIG.speed) * 0.4 + 0.1;
            if(Math.random() < spawnChance && Math.abs(CONFIG.speed) > 0) spawnSmoke();
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i]; p.life -= 0.005; 
                if(p.life <= 0) { scene.remove(p.mesh); p.mesh.material.dispose(); particles.splice(i, 1); } 
                else { p.mesh.scale.multiplyScalar(1.01); p.mesh.material.opacity = p.life * 0.3; }
            }
        }

        // --- TERRAIN ---
        function getTerrainHeight(wx, wz) {
            const h1 = noise.noise2D(wx, wz); 
            const h2 = noise.noise2D(wx * 3, wz * 3) * 0.2;
            
            let h = h1 + h2;
            const zone = noise.noise2D((wx + 12345) * 0.3, (wz + 12345) * 0.3);
            if (zone > 10) {
                const alpha = (zone - 10) / 90; 
                const jagged1 = Math.abs(noise.noise2D(wx * 4, wz * 4)); 
                const jagged2 = Math.abs(noise.noise2D(wx * 10, wz * 10)) * 0.5; 
                h += (alpha * 600) + (alpha * (jagged1 + jagged2) * 4); 
            }
            return Math.max(-50, h);
        }

        function createChunk(cx, cz) {
            const group = new THREE.Group();
            group.userData.monsters = []; 
            group.userData.mapData = { buildings: [], mountains: [] }; 

            const geometry = new THREE.PlaneGeometry(CONFIG.chunkSize, CONFIG.chunkSize, 40, 40);
            geometry.rotateX(-Math.PI / 2);
            const positions = geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const wx = positions[i] + (cx * CONFIG.chunkSize); const wz = positions[i + 2] + (cz * CONFIG.chunkSize);
                positions[i + 1] = getTerrainHeight(wx, wz);
            }
            geometry.computeVertexNormals();
            const material = new THREE.MeshStandardMaterial({ color: 0x444444, map: terrainTexture, roughness: 0.8, metalness: 0.2, flatShading: true });
            const mesh = new THREE.Mesh(geometry, material); mesh.receiveShadow = true; group.add(mesh);

            const buildingGrid = 50; const startX = cx * CONFIG.chunkSize; const startZ = cz * CONFIG.chunkSize; const offset = 5000; 
            for(let x = -CONFIG.chunkSize/2 + 25; x < CONFIG.chunkSize/2; x += buildingGrid) {
                for(let z = -CONFIG.chunkSize/2 + 25; z < CONFIG.chunkSize/2; z += buildingGrid) {
                    const wx = startX + x; const wz = startZ + z; 
                    const zone = noise.noise2D((wx + 12345) * 0.3, (wz + 12345) * 0.3);
                    if(zone > 40) { group.userData.mapData.mountains.push({x: wx, z: wz}); }

                    if(zone < 30) {
                        const val = noise.noise2D(wx + offset, wz + offset);
                        if(val > 25) {
                            const h = getTerrainHeight(wx, wz);
                            if (h > -20) {
                                const bGeo = new THREE.BoxGeometry(20, Math.abs(val) * 2 + 20, 20);
                                const bMat = new THREE.MeshStandardMaterial({ map: buildingTexture, color: 0x888888, roughness: 0.1, metalness: 0.8 });
                                const building = new THREE.Mesh(bGeo, bMat);
                                building.position.set(x, h + (Math.abs(val) * 2 + 20)/2, z); building.castShadow = true; building.receiveShadow = true;
                                group.add(building);
                                group.userData.mapData.buildings.push({x: wx, z: wz});
                            }
                        }
                    }
                }
            }

            const numMonsters = Math.floor(Math.random() * 3); 
            for(let i=0; i<numMonsters; i++) {
                const mx = (Math.random() - 0.5) * CONFIG.chunkSize;
                const mz = (Math.random() - 0.5) * CONFIG.chunkSize;
                const wy = getTerrainHeight(startX + mx, startZ + mz);
                if (wy > -20) { 
                    const m = new Monster(group, mx, mz, wy + 10); 
                    group.userData.monsters.push(m);
                }
            }

            group.position.set(cx * CONFIG.chunkSize, 0, cz * CONFIG.chunkSize); 
            worldGroup.add(group); 
            return group;
        }
        function updateTerrain() {
            const cx = Math.round(ship.position.x / CONFIG.chunkSize); const cz = Math.round(ship.position.z / CONFIG.chunkSize);
            const active = new Set();
            for (let x = -CONFIG.renderDistance; x <= CONFIG.renderDistance; x++) {
                for (let z = -CONFIG.renderDistance; z <= CONFIG.renderDistance; z++) {
                    const key = `${cx+x},${cz+z}`; active.add(key); if (!terrainChunks[key]) terrainChunks[key] = createChunk(cx+x, cz+z);
                }
            }
            for (const key in terrainChunks) { if (!active.has(key)) { worldGroup.remove(terrainChunks[key]); delete terrainChunks[key]; } }
        }

        // --- ENVIRONMENT ---
        function updateEnvironment() {
            const time = performance.now() + (CONFIG.dayDuration * 0.5);
            const progress = (time % CONFIG.dayDuration) / CONFIG.dayDuration;
            const intensityFactor = 0.5 - 0.5 * Math.cos(progress * Math.PI * 2);
            const currentIntensity = CONFIG.minLight + intensityFactor * (CONFIG.maxLight - CONFIG.minLight);
            
            if(ambientLight) ambientLight.intensity = currentIntensity;
            if(sunLight) sunLight.intensity = currentIntensity * 0.5; 

            if(dayPivot) {
                const angle = (progress * 360) + 180;
                dayPivot.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
                if(progress > 0.25 && progress < 0.75) {
                    if(dayIcon.innerText !== '☀') { dayIcon.innerText = '☀'; dayIcon.style.color = '#ffd700'; }
                } else {
                    if(dayIcon.innerText !== '☾') { dayIcon.innerText = '☾'; dayIcon.style.color = '#00ffff'; }
                }
            }
        }

        function updateMonsters() {
            for (const key in terrainChunks) {
                const chunk = terrainChunks[key];
                if (chunk.userData.monsters) {
                    const cx = chunk.position.x;
                    const cz = chunk.position.z;
                    chunk.userData.monsters.forEach(m => {
                        m.update(16, (x, z) => getTerrainHeight(x, z), cx, cz);
                    });
                }
            }
        }

        // --- MINIMAP ---
        function updateMinimap() {
            if (!minimapCtx || mapContainer.style.display === 'none') return;
            const width = mapCanvas.width;
            const height = mapCanvas.height;
            const range = 800; const scale = width / range; 
            
            minimapCtx.clearRect(0, 0, width, height);
            
            // 1. Draw World (Rotated)
            minimapCtx.save();
            minimapCtx.translate(width/2, height/2);
            
            // Rotate map opposite to ship heading so "Forward" is always "Up" on screen
            // Ship Y rotation is CCW. Canvas rotation is CW.
            minimapCtx.rotate(ship.rotation.y);

            const shipX = ship.position.x; const shipZ = ship.position.z;
            
            for(const key in terrainChunks) {
                const chunk = terrainChunks[key];
                if(chunk.userData.mapData) {
                    // Buildings (Cyan)
                    minimapCtx.fillStyle = '#00ffff'; 
                    for(const b of chunk.userData.mapData.buildings) {
                        const relX = (b.x - shipX) * scale; 
                        const relZ = (b.z - shipZ) * scale;
                        // Simple distance cull for performance
                        if (relX*relX + relZ*relZ < (width/2 + 20)**2) { 
                            minimapCtx.beginPath(); 
                            minimapCtx.arc(relX, relZ, 2, 0, Math.PI*2); 
                            minimapCtx.fill(); 
                        }
                    }
                    // Mountains (Red)
                    minimapCtx.fillStyle = '#ff3333'; 
                    for(const m of chunk.userData.mapData.mountains) {
                        const relX = (m.x - shipX) * scale; 
                        const relZ = (m.z - shipZ) * scale;
                        if (relX*relX + relZ*relZ < (width/2 + 20)**2) { 
                            minimapCtx.beginPath(); 
                            minimapCtx.moveTo(relX, relZ - 3); 
                            minimapCtx.lineTo(relX + 3, relZ + 3); 
                            minimapCtx.lineTo(relX - 3, relZ + 3); 
                            minimapCtx.fill(); 
                        }
                    }
                }
            }
            minimapCtx.restore();

            // 2. Draw Ship (Fixed Up)
            minimapCtx.save();
            minimapCtx.translate(width/2, height/2);
            minimapCtx.fillStyle = 'white';
            // No rotation needed here, ship is always Up relative to the rotated map frame
            minimapCtx.beginPath(); 
            minimapCtx.moveTo(0, -6); 
            minimapCtx.lineTo(5, 6); 
            minimapCtx.lineTo(0, 4); 
            minimapCtx.lineTo(-5, 6); 
            minimapCtx.fill();
            minimapCtx.restore();
        }

        // --- PHYSICS ---
        function updatePhysics() {
            if (!isFlying) return;

            if (keys['w']) updateSpeedPct(0.01);
            if (keys['s']) updateSpeedPct(-0.01);

            // Apply gravity based on pitch
            const gravityFactor = 0.002; // Adjust for stronger/weaker gravity
            const pitchInfluence = -Math.sin(shipState.pitch); // Negative pitch (down) = positive influence
            CONFIG.speed += pitchInfluence * gravityFactor;
            CONFIG.speed = Math.max(CONFIG.minSpeed, Math.min(CONFIG.maxSpeed, CONFIG.speed));

            // Update throttle visuals to reflect gravity-adjusted speed
            const currentSpeedPct = (CONFIG.speed - CONFIG.minSpeed) / (CONFIG.maxSpeed - CONFIG.minSpeed);
            const tLevel = document.getElementById('throttle-level');
            const tFill = document.getElementById('throttle-fill');
            if (tLevel && tFill) {
                const px = currentSpeedPct * 100;
                tLevel.style.bottom = `${px}%`;
                tFill.style.height = `${px}%`;
            }

            // --- CAMERA (Parented to Ship, so just handle rotation) ---
            if (useDeviceOrientation) {
                // Device gives absolute orientation. Camera is child of Ship.
                // We need Camera Rotation = (Ship Rotation Inverse) * Device Rotation
                // BUT Device Rotation is world space.
                // Camera.quaternion is Local.
                const qDevice = deviceRefQuat.clone().invert().multiply(currentDeviceQuat); // This is desired world rotation relative to start
                
                // We want CameraWorld = qDevice.
                // CameraLocal = ShipInverse * CameraWorld
                const shipInv = ship.quaternion.clone().invert();
                camera.quaternion.multiplyQuaternions(shipInv, qDevice);
            } else {
                camState.yaw += ((-lookInput.x * 2.0) - camState.yaw) * 0.1;
                camState.pitch += ((-lookInput.y * 1.5) - camState.pitch) * 0.1;
                camera.rotation.set(camState.pitch, camState.yaw, 0, 'YXZ');
            }

            // --- LIGHTS Logic ---
            const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
            const shipFwd = new THREE.Vector3(0, 0, -1).applyQuaternion(ship.quaternion).normalize();
            const angleDiff = shipFwd.angleTo(camDir);
            if (angleDiff < 0.15) { lightMode = 'focus'; } else { lightMode = 'search'; }

            if (lightMode === 'focus') {
                raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                const intersects = raycaster.intersectObjects(worldGroup.children, true);
                const targetPos = new THREE.Vector3();
                if (intersects.length > 0) { targetPos.copy(intersects[0].point); } 
                else { const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); targetPos.copy(camera.position).add(fwd.multiplyScalar(1000)); }
                targetTL.position.lerp(targetPos, 0.01); targetTR.position.lerp(targetPos, 0.008); 
                targetBL.position.lerp(targetPos, 0.006); targetBR.position.lerp(targetPos, 0.004); 
            } else {
                const time = performance.now() * 0.0015; 
                const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd);
                const baseTarget = camera.position.clone().add(fwd.multiplyScalar(600));
                const camRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                const camUp = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);
                const getWander = (tOffset, xMult, yMult) => {
                    const x = Math.sin(time * 0.5 + tOffset) * 400 * xMult;
                    const y = Math.cos(time * 0.3 + tOffset) * 300 * yMult;
                    const pos = baseTarget.clone();
                    pos.add(camRight.clone().multiplyScalar(x)); pos.add(camUp.clone().multiplyScalar(y)); return pos;
                };
                targetTL.position.lerp(getWander(0, 1, 1), 0.01); targetTR.position.lerp(getWander(2, -1, 1), 0.01);
                targetBL.position.lerp(getWander(4, 1, -1), 0.01); targetBR.position.lerp(getWander(5, -1, -1), 0.01);
            }

            // --- SHIP (Always tracks camera view - fly by sight) ---
            const trackingSpeed = 0.08; // How fast ship follows camera (0.0-1.0, higher = faster)

            // Get camera's current local rotation (pitch and yaw relative to ship)
            const camEuler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
            const camLocalPitch = camEuler.x;
            const camLocalYaw = camEuler.y;

            // Make ship track toward camera's local orientation
            shipState.pitch += camLocalPitch * trackingSpeed;
            shipState.yaw += camLocalYaw * trackingSpeed;

            ship.rotation.set(shipState.pitch, shipState.yaw, 0, 'YXZ');

            const forward = new THREE.Vector3(0, 0, -1); forward.applyEuler(ship.rotation);
            ship.position.add(forward.multiplyScalar(CONFIG.speed));

            const h = getTerrainHeight(ship.position.x, ship.position.z);
            if (ship.position.y < h + 10) { ship.position.y = h + 10; shipState.pitch = Math.max(shipState.pitch, 0.05); }
            
            const bx = Math.floor(ship.position.x / 50) * 50 + 25; const bz = Math.floor(ship.position.z / 50) * 50 + 25;
            const val = noise.noise2D(bx + 5000, bz + 5000);
            if (val > 25) {
                const gh = getTerrainHeight(bx, bz);
                const bHeight = Math.abs(val) * 2 + 20;
                if (gh > -20 && Math.abs(ship.position.x - bx) < 12 && Math.abs(ship.position.z - bz) < 12 && ship.position.y < gh + bHeight) {
                    ship.position.sub(forward.multiplyScalar(20)); 
                    ship.rotation.y += Math.PI; shipState.yaw = ship.rotation.y;
                    shipState.pitch = 0.2; ship.rotation.x = shipState.pitch;
                }
            }

            updateHUDVector();
        }
        
        function updateHUDVector() {
            const ind = document.getElementById('vector-indicator');
            const nosePos = new THREE.Vector3(0, 0, -100); nosePos.applyMatrix4(ship.matrixWorld); nosePos.project(camera);
            const x = (nosePos.x * .5 + .5) * window.innerWidth; const y = (-(nosePos.y * .5) + .5) * window.innerHeight;
            if(nosePos.z > 1) { ind.style.display = 'none'; } else { ind.style.display = 'block'; ind.style.left = `${x}px`; ind.style.top = `${y}px`; }
        }

        function updateHUD() {
            if (!altDisp) return;
            altDisp.innerText = Math.floor(ship.position.y).toString().padStart(4, '0');
            spdDisp.innerText = `MACH ${CONFIG.speed.toFixed(1)}`;
            const camEuler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
            let deg = (camEuler.y * 180 / Math.PI) % 360; if (deg < 0) deg += 360;
            compassDial.style.transform = `rotate(${deg}deg)`;
            headingText.innerText = Math.floor(deg).toString().padStart(3, '0');
            
            const pitchPx = THREE.MathUtils.radToDeg(camEuler.x) * 2; 
            const rollDeg = THREE.MathUtils.radToDeg(camEuler.z);
            if(horizonBar) horizonBar.style.transform = `translate(-50%, calc(-50% + ${pitchPx}px)) rotate(${-rollDeg}deg)`;
        }

        function animate() {
            requestAnimationFrame(animate);
            updateKeyboardJoystick();
            updatePhysics();
            updateTerrain();
            updateMonsters();
            updateParticles();
            updateAudio();
            updateEnvironment();
            updateMinimap();
            renderer.render(scene, camera);
            if(isFlying) updateHUD();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setLightIntensity(pct) {
            const lLevel = document.getElementById('light-level'); const lFill = document.getElementById('light-fill');
            const px = pct * 100; lLevel.style.bottom = `${px}%`; lFill.style.height = `${px}%`;
            const intensity = pct * 10.0; 
            if(spotTL) {
                spotTL.intensity = intensity;
                spotTR.intensity = intensity;
                spotBL.intensity = intensity;
                spotBR.intensity = intensity;
            }
        }

        function updateThrottleVisuals(pct) {
            const tLevel = document.getElementById('throttle-level'); const tFill = document.getElementById('throttle-fill');
            const px = pct * 100; tLevel.style.bottom = `${px}%`; tFill.style.height = `${px}%`;
            // Linear mapping from Min to Max
            CONFIG.speed = CONFIG.minSpeed + (pct * (CONFIG.maxSpeed - CONFIG.minSpeed));
        }

        function updateSpeedPct(delta) {
            let pct = (CONFIG.speed - CONFIG.minSpeed) / (CONFIG.maxSpeed - CONFIG.minSpeed);
            pct += delta;
            setSpeedPct(pct);
        }

        function setSpeedPct(pct) { pct = Math.max(0, Math.min(1, pct)); updateThrottleVisuals(pct); }

        function updateJoystickVisual(x, y) { 
             const jKnob = document.getElementById('joystick-knob');
             const jMax = 35;
             if(jKnob) jKnob.style.transform = `translate(${x * jMax}px, ${y * jMax}px)`;
        }

        function updateKeyboardJoystick() {
            if(isUsingJoystick) return; 
            let jx = 0; let jy = 0;
            if (keys['arrowleft']) jx -= 1; if (keys['arrowright']) jx += 1; if (keys['arrowup']) jy -= 1; if (keys['arrowdown']) jy += 1;
            joyInput.x = jx; joyInput.y = jy;
            if (jx !== 0 || jy !== 0 || (joyInput.x === 0 && joyInput.y === 0)) updateJoystickVisual(jx, jy);
        }

        function setupControls() {
            // Light Mode Toggle
            const btn = document.getElementById('light-mode-btn');
            const toggleLightMode = (e) => {
                if(e && e.type !== 'keydown') { e.preventDefault(); e.stopPropagation(); }
                lightMode = (lightMode === 'focus') ? 'search' : 'focus';
                btn.innerText = (lightMode === 'focus') ? '⌖' : '≡';
            };
            btn.addEventListener('click', toggleLightMode);
            btn.addEventListener('touchstart', toggleLightMode);

            // Input Listeners
            window.addEventListener('keydown', (e) => {
                const k = e.key.toLowerCase(); keys[k] = true;
                if (e.key >= '0' && e.key <= '9') setLightIntensity(parseInt(e.key) / 9);
                if (e.key === '=' || e.key === '+') toggleLightMode(e);
            });
            window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

            const jZone = document.getElementById('joystick-zone');
            const handleJoy = (touch) => {
                const rect = jZone.getBoundingClientRect();
                const dx = touch.clientX - (rect.left + rect.width/2); const dy = touch.clientY - (rect.top + rect.height/2);
                const dist = Math.sqrt(dx*dx + dy*dy); let fx = dx, fy = dy;
                if(dist > 35) { const angle = Math.atan2(dy, dx); fx = Math.cos(angle) * 35; fy = Math.sin(angle) * 35; }
                joyInput.x = fx / 35; joyInput.y = fy / 35; updateJoystickVisual(joyInput.x, joyInput.y);
            };
            jZone.addEventListener('touchstart', e => { e.preventDefault(); isUsingJoystick = true; handleJoy(e.touches[0]); });
            jZone.addEventListener('touchmove', e => { e.preventDefault(); if(isUsingJoystick) handleJoy(e.touches[0]); });
            jZone.addEventListener('touchend', e => { isUsingJoystick = false; joyInput.x = 0; joyInput.y = 0; updateJoystickVisual(0,0); });

            const tZone = document.getElementById('throttle-zone');
            const handleThrottle = (clientY) => {
                const rect = tZone.getBoundingClientRect(); let pct = 1.0 - ((clientY - rect.top) / rect.height); setSpeedPct(pct);
            };
            tZone.addEventListener('touchstart', e => { e.preventDefault(); handleThrottle(e.touches[0].clientY); });
            tZone.addEventListener('touchmove', e => { e.preventDefault(); handleThrottle(e.touches[0].clientY); });
            
            let mouseDownT = false; tZone.addEventListener('mousedown', e => { mouseDownT = true; handleThrottle(e.clientY); });
            window.addEventListener('mousemove', e => { if(mouseDownT) handleThrottle(e.clientY); });
            window.addEventListener('mouseup', () => { mouseDownT = false; });

            const lZone = document.getElementById('light-zone');
            const handleLights = (clientY) => {
                const rect = lZone.getBoundingClientRect(); let pct = 1.0 - ((clientY - rect.top) / rect.height); pct = Math.max(0, Math.min(1, pct)); setLightIntensity(pct);
            };
            lZone.addEventListener('touchstart', e => { e.preventDefault(); handleLights(e.touches[0].clientY); });
            lZone.addEventListener('touchmove', e => { e.preventDefault(); handleLights(e.touches[0].clientY); });
            let mouseDownL = false; lZone.addEventListener('mousedown', e => { mouseDownL = true; handleLights(e.clientY); });
            window.addEventListener('mousemove', e => { if(mouseDownL) handleLights(e.clientY); });
            window.addEventListener('mouseup', () => mouseDownL = false);

            document.addEventListener('mousemove', (e) => {
                if(!isFlying || isUsingJoystick || useDeviceOrientation || mouseDownT || mouseDownL) return;
                lookInput.x = (e.clientX / window.innerWidth) * 2 - 1; lookInput.y = (e.clientY / window.innerHeight) * 2 - 1;
            });

            const handleOrientation = (event) => {
                if(!event.alpha) return;
                useDeviceOrientation = true;
                const orient = window.orientation || 0;
                setQuaternion(currentDeviceQuat, event.alpha, event.beta, event.gamma, orient);
            };

            document.getElementById('start-btn').addEventListener('click', () => {
                initAudio();
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission().then(r => {
                        if (r === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            setTimeout(() => { deviceRefQuat.copy(currentDeviceQuat); }, 500);
                        }
                    });
                } else {
                    window.addEventListener('deviceorientation', handleOrientation);
                    setTimeout(() => { deviceRefQuat.copy(currentDeviceQuat); }, 500);
                }
                document.getElementById('ui-layer').classList.add('hidden');
                document.getElementById('hud').style.display = 'block';
                document.getElementById('compass-container').style.display = 'block';
                
                // HIDE CONTROLS (Ensured)
                document.getElementById('joystick-zone').style.display = 'none';
                document.getElementById('throttle-zone').style.display = 'none';
                document.getElementById('light-zone').style.display = 'none';
                document.getElementById('key-hint').style.display = 'none';
                
                // SHOW MAP (Always on)
                document.getElementById('minimap-container').style.display = 'block';
                
                // Initialize throttle to 0% (Which is now Min Speed 0.5)
                updateThrottleVisuals(0.0);
                
                // Initialize Lights: Search Mode @ 100% (Max) as requested earlier
                lightMode = 'search';
                document.getElementById('light-mode-btn').innerText = '≡';
                setLightIntensity(1.0);

                isFlying = true;
            });
        }

        init();
    </script>
</body>
</html>